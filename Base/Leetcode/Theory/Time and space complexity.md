---
tags:
  - leetcode
  - draft
---
## Big O

`O(...)` - используется для описания того, насколько возрастает количество операций при увеличении количества входных параметров. Обычно применяется для сравнения эффективности между алгоритмами.

Также `O(...)` может использоваться для оценки сложности по памяти. Рассчитывается память, которая была использована во время выполнения алгоритма. Выделение памяти под параметры функции не учитываются.

## Правила для подсчета сложности

При подсчитывании сложности важно лишь примерная её оценка, то есть константы могут быть отброшены.

`O(2)` превратится в `O(1)`.
`O(2n)` превратится в `O(n)`.
`O(2n + n^2 + n)` превратится в `O(n^2)`.
## O(1)

### По времени

Сложность алгоритма по времени `O(1)`, если размер передаваемых данных не влияет на производительность.

Время выполнения функции ниже не зависит от количества данных, которое в неё будет передаваться.

```typescript
const sayHello = (args) => {
  console.log('hello');
}
```

### По памяти

Сложность алгоритма по памяти `O(1)`, если размер передаваемых данных не влияет на выделение дополнительной памяти во время выполнения алгоритма.

В коде ниже только выделяется память под переменную `i`, нет дополнительных структур размер которых увеличивался с количеством входных данных.

```typescript
const iterateCycle = (nums) => {
  for (let i = 0; i < nums.length; i++) {
    console.log(nums[i]);
  }
}
```
## O(n)

### По времени

Сложность алгоритма по времени `O(n)`, если размер передаваемых данных линейно влияет на производительность.

В коде ниже осуществляется проход по массиву с использованием цикла, количество операций в цикле линейно зависят от размера массива, если массив будет из 5 элементов, то и цикл выполнится 5 раз, поэтому время выполнения будет `O(n)`.

```typescript
const nums = [1, 2, 3, 4, 5];

for (let i = 0; i < nums.length; i++) {
  console.log(nums[i]);
}
```

Здесь два цикла, который проходятся по разным массивам, поэтому можно сказать, что сложность будет `O(n + m)`, где `n` - длина массива `nums`, а `k` - длина массива `strings`. Но так как нас интересует примерная оценка, то можно упростить до `O(n)`.

```typescript
const nums = [1, 2, 3, 4, 5];
const strings = ['a', 'b', 'c', 'd', 'f'];

for (let i = 0; i < nums.length; i++) {
  console.log(nums[i]);
}

for (let i = 0; i < strings.length; i++) {
  console.log(nums[i]);
}
```

### По памяти

Сложность алгоритма по памяти `O(n)`, если размер передаваемых данных линейно влияет на количество дополнительной памяти, которое выделяется при выполнении алгоритма.

В коде ниже дополнительная память выделяется под переменную `out`, если `nums` будет длиной в 10 элементов, то и `out` будет в 10 элементов, поэтому сложность `O(n)`.
 
```typescript
const iterateCycle = (nums) => {
  const out = [];

  for (let i = 0; i < nums.length; i++) {
    out.push(nums[i]);
  }
}
```
## O(n^2)

### По времени

Сложность алгоритма по времени `O(n^2)`, если размер передаваемых данных квадратично влияет на производительность.

В коде ниже присутствуют два цикла, оба из них выполняются за `O(n)`, поэтому и сложность такого алгоритма `O(n*n)` или `O(n^2)`, если бы внутри был ещё один цикл, то сложность возросла бы до `O(n^3)`.

```typescript
const numbers = [1, 2, 3, 4, 5];

for (let i = 0; i < numbers.length; i++) {
	for (let j = 0; j < numbers.length; j++) {
	  console.log(`${i}, ${j}`);
	}
}
```
## O(log n)

### По времени

Сложность алгоритма по времени `O(log n)`, если размер передаваемых данных логарифмически влияет на производительность, за основание обычно берется логарифм с основанием `10`.

Примером такого алгоритма может быть `бинарный поиск`, где на каждой итерации отсекается около половины элементов.
## O(2^n)

### По времени

Сложность алгоритма по времени `O(2^n)`, если размер передаваемых данных экспоненциально влияет на производительность алгоритма.

```typescript
const fibonacci = (n) => {
  if (n === 0) return 0;
  if (n === 1) return 1;
    
  return fibonacci(n-1) + fibonacci(n-2);
}
```

![[algorithm_efficiency.jpg]]


TODO: Добавить инфу про сложность по памяти:
1. https://www.geeksforgeeks.org/g-fact-86/;
2. https://www.faceprep.in/data-structures/space-complexity/.