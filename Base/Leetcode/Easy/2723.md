2023-10-10 21:02
Tags: #leetcode
## Description

Given two promises `promise1` and `promise2`, return a new promise. `promise1` and `promise2` will both resolve with a number. The returned promise should resolve with the sum of the two numbers.

**Example 1:**
>**Input:**
	`promise1 = new Promise(resolve => setTimeout(() => resolve(2), 20))`
	`promise2 = new Promise(resolve => setTimeout(() => resolve(5), 60))`
>**Output:** `7`

**Example 1:**
>**Input:**
	`promise1 = new Promise(resolve => setTimeout(() => resolve(10), 50))`
	`promise2 = new Promise(resolve => setTimeout(() => resolve(-12), 30))`
>**Output:** `-2`

## Answers

### Answer 1

Сначала появилось желание написать так, но здесь есть недостаток:
1. `await` блокирует выполнение следующих строк кода, пока текущий промис не обработается;

```typescript
type P = Promise<number>

async function addTwoPromises(promise1: P, promise2: P): P {
	const value1 = await promise1;
    const value2 = await promise2;

    return value1 + value2;
};

```
### Answer 2

Через `Promise.all` достигается некая параллельность, потому что обрабатывается несколько промисов сразу.

```typescript
type P = Promise<number>

async function addTwoPromises(promise1: P, promise2: P): P {
	const [value1, value2] = await Promise.all([promise1, promise2]);
	
    return value1 + value2;
};
   
```

Функция с `async` возвращает промис, поэтому в коде можно вернуть значение, а не промис.