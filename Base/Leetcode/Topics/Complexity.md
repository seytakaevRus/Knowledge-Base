## Big O

`O(...)` - используется для описания того, насколько возрастает количество операций при увеличении количества входных параметров. Обычно применяется для сравнения эффективности между алгоритмами.

Сложность разделяют по:
1. времени;
2. памяти.

## Правила для подсчета сложности

При подсчитывании сложности важно лишь примерная её оценка, то есть константы могут быть отброшены.

`O(2)` превратится в `O(1)`.
`O(2n)` превратится в `O(n)`.
`O(2n + n^2 + n)` превратится в `O(n^2)`.
## O(1)

Время работы алгоритма `O(1)`, если размер передаваемых данных не влияет на производительность.

Время выполнения функции ниже не зависит от количества данных, которое в неё будет передаваться.

```typescript
const sayHello = (args) => {
	console.log('hello');
}
```
## O(n)

Время работы алгоритма `O(n)`, если размер передаваемых данных линейно влияет на производительность.

В коде ниже осуществляется проход по массиву с использованием цикла, количество операций в цикле линейно зависят от размера массива, поэтому время выполнения будет `O(n)`.

```typescript
const nums = [1, 2, 3, 4, 5];

for (let i = 0; i < nums.length; i++) {
   console.log(nums[i]);
}
```

Здесь два цикла, который проходятся по разным массивам, поэтому можно сказать, что сложность будет `O(n + m)`, где `n` - длина массива `nums`, а `k` - длина массива `strings`. Но так как нас интересует примерная оценка, то можно упростить до `O(n)`.

```typescript
const nums = [1, 2, 3, 4, 5];
const strings = ['a', 'b', 'c', 'd', 'f'];

for (let i = 0; i < nums.length; i++) {
   console.log(nums[i]);
}

for (let i = 0; i < strings.length; i++) {
	console.log(nums[i]);
}
```
## O(n^2)

Время работы алгоритма `O(n^2)`, если размер передаваемых данных квадратично влияет на производительность.

В коде ниже присутствуют два цикла, оба из них выполняются за `O(n)`, поэтому и сложность такого алгоритма `O(n*n)` или `O(n^2)`, если бы внутри был ещё один цикл, то сложность возросла бы до `O(n^3)`.

```typescript
const numbers = [1, 2, 3, 4, 5];

for (let i = 0; i < numbers.length; i++) {
    for (let j = 0; j < numbers.length; j++) {
        console.log(`${i}, ${j}`);
    }
}
```
## O(log n)

Время работы алгоритма `O(log n)`, если размер передаваемых данных логарифмически влияет на производительность, за основание обычно берется логарифм с основанием `10`.

Примером такого алгоритма может быть `бинарный поиск`, где на каждой итерации отсекается около половины элементов.
## O(2^n)

Время работа алгоритма `O(2^n)`, если размер передаваемых данных экспоненциально влияет на производительность алгоритма.

```typescript
const fibonacci = (n) => {
    if (n === 0) return 0;
    if (n === 1) return 1;
    
    return fibonacci(n-1) + fibonacci(n-2);
}
```