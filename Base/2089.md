---
level: easy
tags:
  - leetcode
linkToTask: https://leetcode.com/problems/find-target-indices-after-sorting-array/description/
linkToIndex:
  - "[[Array]]"
  - "[[Binary Search]]"
topics:
  - array
  - binary search
---
## Description

Дается массив чисел `nums` и элемент-цель `target`. Нужно отсортировать массив в возрастающем порядке и вернуть массив, где будут все индексы `target` в `nums`. Если `target` нет в `nums`, то вернуть пустой массив.

---
## Constraints

- `1 <= nums.length <= 100`
- `1 <= nums[i], target <= 100`

---
## Example 1

### Input

```
nums = [1,2,5,2,3]
target = 2
```
### Output

```
[1,2]
```
### Explanation

```
After sorting, nums is [1,**2**,**2**,3,5].
The indices where nums[i] == 2 are 1 and 2.
```

---
## Example 2

### Input

```
nums = [1,2,5,2,3]
target = 5
```
### Output

```
[4]
```
### Explanation

```
After sorting, nums is [1,2,2,3,**5**].
The index where nums[i] == 5 is 4.
```

---
## Answers

### Answer 1

Используется два бинарных поиска, первый ищет первое вхождение цели

```typescript
const searchFirstIndexTarget = (nums: number[], target: number) => {
  let left = 0;
  let right = nums.length - 1;

  while (left <= right) {
    const middle = Math.floor((left + right) / 2);

    if (nums[middle] < target) {
      left = middle + 1;
    } else if (nums[middle] >= target) {
      right = middle - 1;
    }
  }

  if (nums[right + 1] === target) {
    return right + 1;
  }

  return -1;
}

const searchLastIndexTarget = (nums: number[], target: number) => {
  let left = 0;
  let right = nums.length - 1;

  while (left <= right) {
    const middle = Math.floor((left + right) / 2);

    if (nums[middle] <= target) {
      left = middle + 1;
    } else if (nums[middle] > target) {
      right = middle - 1;
    }
  }

  if (nums[left - 1] === target) {
    return left - 1;
  }

  return -1;
}

const targetIndices = (nums: number[], target: number): number[] => {
  const output = [];

  nums.sort((a, b) => a - b);

  const targetFirsOccurence = searchFirstIndexTarget(nums, target);
  const targetLastOccurence = searchLastIndexTarget(nums, target);

  if (targetFirsOccurence === -1 || targetLastOccurence === -1) {
    return [];
  }

  for (let i = targetFirsOccurence; i <= targetLastOccurence; i += 1) {
    output.push(i);
  }

  return output;
};```

Сложность по времени: `O(n * log n + log n)`.

Сложность по памяти: `O(log n)`.

---
### Answer 2

```typescript
```

Сложность по времени: `O()`.

Сложность по памяти: `O()`.

