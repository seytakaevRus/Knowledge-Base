---
level: middle
tags:
  - leetcode
linkToTask: https://leetcode.com/problems/count-nice-pairs-in-an-array/?envType=daily-question&envId=2023-11-21
linkToIndex:
  - "[[Array]]"
  - "[[Hash]]"
  - "[[Counting]]"
  - Math
topics:
  - array
  - hash
  - counting
  - math
---
## Description

Дается массив положительных чисел `nums`. Пусть `rev(x)` это число, чьи цифры идут в обратном порядке числа `x`. Для примера, `rev(123) = 321` и `rev(120) = 21`. Пара индикатор `(i, j)` подходит, если она удовлетворяет следующим условиям:
1. `0 <= i < j < nums.length`;
2. `nums[i] + rev(nums[j]) === nums[j] + rev(nums[i])`.

Вернуть количество пар, которые подходят под условия выше.

---
## Constraints

- `1 <= nums.length <= 105`
- `0 <= nums[i] <= 109`

---
## Example 1

### Input

```
nums = [42,11,1,97]
```
### Output

```
2
```
### Explanation

```
The two pairs are:
 - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.
 - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.
```

---
## Example 2

### Input

```
nums = [13,10,35,24,76]
```
### Output

```
4
```

---
## Answers

### Answer 0

Первое, что приходит на ум, это брутфорс, но на `leetcode` оно упадет с ошибкой `Time Limit Exceeded`.

```typescript
const reverseInteger = (value: number): number => {
	let temp = value;
	let result = 0;

	while (temp > 0) {
		const lastDigit = temp % 10;

		result = result * 10 + lastDigit;

		temp = Math.trunc(temp / 10);
	}

	return result;
}

const countNicePairs = (nums: number[]): number => {
	let result = 0;

	for (let i = 0; i < nums.length; i += 1) {
		for (let j = i + 1; j < nums.length; j += 1) {
			if (nums[i] + reverseInteger(nums[j]) === nums[j] + reverseInteger(nums[i])) {
				result += 1;
			}
		}
	}

	return result;
};
```

---
### Answer 1

```typescript
```

Сложность по времени: `O()`.

Сложность по памяти: `O()`.

