#typescript 
## интерфейсы - сущность из мира ООП
Изначально в языках была проблема с множественным наследованием от абстрактных классов. К примеру в C++ отсутствуют интерфейсы и это вызывает неудобства: когда мы наследуемся от нескольких классов, то непонятно какую реализацию должен подтягивать язык. В итоге typescript, Java, C# и так далее решили пойти по другому пути. В этих языках добавлены интерфейсы. Класс может имплементить большое количество интерфейсов (сами интерфейсы могут расширяться другими интерфейсами), но наследоваться можно только от одного класса (это кстати главное отличие интерфейса от абстрактного класса). То есть типов может быть много, а реализация только одна.
Классы не удобно имплементить от типов, так как если тип, который мы имплементим, будет union типом, то тайпскрипт будет жаловаться:

```typescript
type SecondType = {
	c: string;
}

type ClassType = {
	a: string;
	b: string;
} | SecondType;

class MyClass implements ClassType {//A class can only implement an object type or intersection of object types with statically known members
	a: string = "a";
	b: string = "b";
}
```
## типы подходят для union и intersection
В типах мы можем объединять другие типы
```typescript
type MyType = number | string;
```

## Типы и интерфейcы могут наследоваться друг от друга
```ts
type SecondType = {

}

interface FirstType extends SecondType {

}
type ThirdType = SecondType | FirstType;
```

## и типом и интерфейсом можно типизировать функции
```ts
interface Type1 {
	(myArg: any): void;
}

type Type2 = (myArg: any) => void;
```

Кроме того, и типами и интерфейсами можно типизировать различные объекты (например: пропсы можно типизировать как типами так и интерфейсами).

## Интерфейсы могут джойниться
```ts
interface I {
	name: string;
}

interface I {
	age: number;
}

const user: I = {
	name: "Karen",
	age: 24,
}
```
Это свойство интерфейсов позволяет расширять какой-то уже готовый функционал.